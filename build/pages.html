<h1 id="kram---a-class-based-scripting-language">Kram - A class based scripting language</h1>

<h1 id="getting-started">Getting started</h1>
<p>Getting started is as easy as 1-2-3!</p>
<h2 id="building">Building</h2>
<h3 id="unix">Unix</h3>
<p>The only requirement is that you have a compiler that supports C++11 (g++/gcc 4.8 and higher). Then the following two commands should do everything you need!</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone git@github.com:kram/kram.git
$ <span class="kw">make</span></code></pre></div>
<h2 id="executing">Executing</h2>
<p>When you have your kram binary ready you're ready to rock, just execute <code>kram /path/to/script.kr</code> and you're done! Congratulations on executing your first kram script!</p>
<h2 id="hello-world">Hello World</h2>
<p>One of the main goals of kram is to have an <em>extremely</em> low point of entry, a Hello World is as simple as</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">IO::Println(<span class="st">&quot;Hello World!&quot;</span>)</code></pre></div>
<p>You're a kram programmer now! If you have any questions, have found any bugs or want to contribute to the project and of the following methods are great!</p>
<ul>
<li><a href="https://github.com/kram/kram/issues">File a ticket</a> in our repository at <a href="https://github.com/kram/kram">GitHub</a></li>
<li>Write to me at Twitter, <span class="citation">[@zegl]</span>(https://twitter.com/zegl)</li>
</ul>

<h1 id="control-flow">Control flow</h1>
<h2 id="if-else">If / Else</h2>
<p><code>if</code> and <code>else</code> are currently the only available control structures implemented in kram.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">if</span> condition {
    <span class="co">// Was true</span>
} <span class="kw">else</span> {
    <span class="co">// Not true</span>
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">if</span> condition {
    <span class="co">// Was true</span>
}</code></pre></div>
<h2 id="while">While</h2>
<p>kram only has a simple way of looping (for now), the <code>while</code>-loop.</p>
<h3 id="example">Example</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="co">// Prints the numbers 1 to 10</span>
i := <span class="dv">1</span>

while i &lt;= <span class="dv">10</span> {
    IO::Println(i)
    i := <span class="dv">1</span>
}</code></pre></div>

<h1 id="types">Types</h1>
<p>All values in kram are deriving from the default <code>Class</code>-object. These are the default <em>builtin</em> values in kram that all other types (aka Methods/Classes/Libraries) derive from.</p>

<h1 id="types-number">Types / Number</h1>
<p>A <code>Number</code> is the only way to represent a number (eg, 10, 1337 or 123.456) in kram.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> positive = <span class="dv">1337</span>
<span class="kw">var</span> price = <span class="dv">999</span><span class="fl">.95</span></code></pre></div>
<h2 id="methods">Methods</h2>
<p><em>More methods will be added when needed, see https://golang.org/pkg/math for ideas.</em></p>
<h3 id="number.sqrt-number"><code>Number.Sqrt() Number</code></h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">IO::Println(<span class="dv">100</span>.Sqrt()) <span class="co">// 10</span></code></pre></div>

<h1 id="types-string">Types / String</h1>
<p><code>String</code>s are a piece of UTF-8 text, and they are defined by the usage of double quotes (<code>&quot;</code>)</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> hello = <span class="st">&quot;World&quot;</span></code></pre></div>
<h2 id="methods">Methods</h2>
<p><em>Methods will be added when needed, see https://golang.org/pkg/strings/ for ideas.</em></p>

<h1 id="types-bool">Types / Bool</h1>
<p><code>Bool</code> can only have two states, <code>true</code> or <code>false</code>.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> success = <span class="ot">true</span>
<span class="kw">var</span> fail = <span class="ot">false</span></code></pre></div>

<h1 id="types-map">Types / Map</h1>
<p>A <code>Map</code> is what other languages might call a dict or hashmap/unordered map.</p>
<p>The key must be a <code>String</code>, but the value can be of any type (even other <code>Map</code>s if you wish).</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="co">// Initialize new Map</span>
friends := <span class="fu">new</span> Map()

<span class="co">// Creates &quot;Rachel&quot; and &quot;Monica&quot;</span>
friends.Set(<span class="st">&quot;Rachel&quot;</span>, <span class="st">&quot;Green&quot;</span>)
friends.Set(<span class="st">&quot;Monica&quot;</span>, <span class="st">&quot;Geller&quot;</span>)

IO::Println(friends.Get(<span class="st">&quot;Monica&quot;</span>)) <span class="co">// Prints &quot;Geller&quot;</span>

<span class="kw">if</span> friends.Has(<span class="st">&quot;Ross&quot;</span>) {
    <span class="co">// Do something with the fact that &quot;Ross&quot; does/doesn&#39;t exist    </span>
}</code></pre></div>
<h2 id="methods">Methods</h2>
<h3 id="map.setstring-type"><code>Map.Set(String, Type)</code></h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">capitals := <span class="fu">new</span> Map()
capitals.Set(<span class="st">&quot;Denmark&quot;</span>, <span class="st">&quot;Copenhagen&quot;</span>)
capitals.Set(<span class="st">&quot;Germany&quot;</span>, <span class="st">&quot;Berlin&quot;</span>)</code></pre></div>
<h2 id="map.getstring-type"><code>Map.Get(String) Type</code></h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">capitals.Get(<span class="st">&quot;Denmark&quot;</span>) <span class="co">// Copenhagen</span></code></pre></div>
<h2 id="map.hasstring-bool"><code>Map.Has(String) Bool</code></h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">capitals.Has(<span class="st">&quot;Germany&quot;</span>) <span class="co">// true</span>
capitals.Has(<span class="st">&quot;Norway&quot;</span>) <span class="co">// false</span></code></pre></div>

<h1 id="types-function">Types / Function</h1>
<p><code>Function</code>s are just another Type, and can be assigned to variables like any other.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="co">// Create new function</span>
get_three := fn() {
    <span class="co">// The last statement of a function is returned (see &quot;Return Values&quot;)</span>
    <span class="dv">3</span>
}

<span class="co">// A function is executed with ()</span>
three := get_three()

IO::Println(three) <span class="co">// 3</span></code></pre></div>
<h2 id="arguments-and-parameters">Arguments and parameters</h2>
<p>You can pass arguments to functions the same way as other C-like languages.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">myPrint := fn(input) {
    IO::Println(input)
}

myPrint(<span class="st">&quot;Hello World!&quot;</span>)</code></pre></div>
<p>Multiple arguments can be passed to a function by seperating them with commas</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">multiPrint := fn(first, second, third) {
    IO::Println(first)
    IO::Println(second)
    IO::Println(third)
}

myPrint(<span class="st">&quot;One&quot;</span>, <span class="st">&quot;Two&quot;</span>, <span class="st">&quot;Three!&quot;</span>)</code></pre></div>
